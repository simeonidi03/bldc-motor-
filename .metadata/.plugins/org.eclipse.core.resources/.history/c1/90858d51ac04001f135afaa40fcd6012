/**
  **************************************************************************
  * @file     main.c
  * @version  v2.0.0
  * @date     2020-11-02
  * @brief    main program
  **************************************************************************
  *                       Copyright notice & Disclaimer
  *
  * The software Board Support Package (BSP) that is made available to
  * download from Artery official website is the copyrighted work of Artery.
  * Artery authorizes customers to use, copy, and distribute the BSP
  * software and its related documentation for the purpose of design and
  * development in conjunction with Artery microcontrollers. Use of the
  * software is governed by this copyright notice and the following disclaimer.
  *
  * THIS SOFTWARE IS PROVIDED ON "AS IS" BASIS WITHOUT WARRANTIES,
  * GUARANTEES OR REPRESENTATIONS OF ANY KIND. ARTERY EXPRESSLY DISCLAIMS,
  * TO THE FULLEST EXTENT PERMITTED BY LAW, ALL EXPRESS, IMPLIED OR
  * STATUTORY OR OTHER WARRANTIES, GUARANTEES OR REPRESENTATIONS,
  * INCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
  *
  **************************************************************************
  */

#include "at32f403a_407_board.h"
#include "at32f403a_407_clock.h"
#include <string.h>
#include "servo.h"

/** @addtogroup AT32F403A_periph_examples
  * @{
  */

/** @addtogroup 403A_I2C_communication_int I2C_communication_int
  * @{
  */

#define TMRx_PR 1000
#define BIT_NUMBER 8


#define BUF_SIZE                         2
//#define MASTER_BOARD

uint8_t tx_buf[BUF_SIZE] = {0x01, 0x02};//, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
uint8_t rx_buf[BUF_SIZE] = {2, 30};



void error_handler(uint32_t error_code);




uint16_t PWM_DataLength = 0;
tmr_output_config_type tmr_output_struct;

uint16_t src_buffer[BIT_NUMBER] = {};
/**
  * @brief  error handler program
  * @param  i2c_status
  * @retval none
  */
void error_handler(uint32_t error_code)
{
  while(1)
  {
    at32_led_toggle(LED2);
    delay_ms(500);
  }
}



/**
  * @brief  configures the different system clocks.
  * @param  none
  * @retval none
  */
void crm_configuration(void)
{
  /* tmr clock enable */
  crm_periph_clock_enable(CRM_TMR3_PERIPH_CLOCK, TRUE);

  /* gpio clock enable */
  crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);

	/* dma clock enable */
  crm_periph_clock_enable(CRM_DMA1_PERIPH_CLOCK, TRUE);
}

/**
  * @brief  configures the PWM dma duty cycle parameters.
  * @param  none
  * @retval none
  */
void TMR3_DMA_Duty_Cycle(void)
{

	/* set tmr channel CC value */
	tmr_channel_value_set(TMR3, TMR_SELECT_CHANNEL_4, 0);

  /* config set the number of data to be transferred by dma */
  dma_channel_enable(DMA1_CHANNEL3, FALSE);
  dma_data_number_set(DMA1_CHANNEL3, PWM_DataLength);
  dma_channel_enable(DMA1_CHANNEL3, TRUE);

	/* TMR enable counter */
	tmr_counter_enable(TMR3, TRUE);

	/* wait for the end of dma transfer */
	while (!dma_flag_get(DMA1_FDT3_FLAG));
	/* Clear dma flag */
	dma_flag_clear(DMA1_FDT3_FLAG);

	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET!=tmr_flag_get(TMR3, TMR_OVF_FLAG));
	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET != tmr_flag_get(TMR3, TMR_OVF_FLAG));

	/* TMR disable counter */
	tmr_counter_enable(TMR3, FALSE);

}


void gpio_configuration(void)
{
  gpio_init_type gpio_init_struct;

  gpio_default_para_init(&gpio_init_struct);

	/* configure PB1 tmr3_ch4 as output*/
  gpio_init_struct.gpio_pins = GPIO_PINS_1;
  gpio_init_struct.gpio_mode = GPIO_MODE_MUX;
  gpio_init(GPIOB, &gpio_init_struct);
}


void dma_configuration(void)
{
	dma_init_type dma_init_struct = {0};
	uint16_t index = 0;

	while(index < PWM_DataLength)
	{

		src_buffer[index] = (uint16_t) (((uint32_t) (src_buffer[index]) * (TMRx_PR)) / (1000));
		index++;
	}

  /* dma1 channel7 configuration */
  dma_default_para_init(&dma_init_struct);

  dma_init_struct.buffer_size = PWM_DataLength;
  dma_init_struct.direction = DMA_DIR_MEMORY_TO_PERIPHERAL;
  dma_init_struct.memory_base_addr = (uint32_t)src_buffer;
  dma_init_struct.memory_data_width = DMA_MEMORY_DATA_WIDTH_HALFWORD;
  dma_init_struct.memory_inc_enable = TRUE;
  dma_init_struct.peripheral_base_addr = (uint32_t)&TMR3->c4dt;
  dma_init_struct.peripheral_data_width= DMA_PERIPHERAL_DATA_WIDTH_HALFWORD;
  dma_init_struct.peripheral_inc_enable  = FALSE;
  dma_init_struct.priority = DMA_PRIORITY_HIGH;
  dma_init_struct.loop_mode_enable = FALSE;
  dma_init(DMA1_CHANNEL3, &dma_init_struct);
}


/**
  * @brief  configure the tmr parameters.
  * @param  none
  * @retval none
  */
void tmr_configuration(void)
{
  /* Init TMR3 */
	//2603879
  tmr_base_init(TMR3, TMRx_PR-1, 1500);
  tmr_cnt_dir_set(TMR3, TMR_COUNT_UP);

	/* TMR configuration as output mode */
  tmr_output_default_para_init(&tmr_output_struct);
  tmr_output_struct.oc_mode = TMR_OUTPUT_CONTROL_PWM_MODE_A;
  tmr_output_struct.oc_output_state = TRUE;
  tmr_output_struct.oc_polarity = TMR_OUTPUT_ACTIVE_LOW;

	/* TMR3 channel 4 configuration */
  tmr_output_channel_config(TMR3, TMR_SELECT_CHANNEL_4, &tmr_output_struct);

	/* enable tmr output channel buffer */
  tmr_output_channel_buffer_enable(TMR3, TMR_SELECT_CHANNEL_4, TRUE);
}

/**
  * @brief  main function.
  * @param  none
  * @retval none
  */
int main(void)
{

    /* config nvic priority group */
    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);

    system_clock_config();

    at32_board_init();

    crm_configuration();

    /* tmr gpio configuration */
    gpio_configuration();

    /* dma configuration */
    dma_configuration();

    /* tmr configuration */
    tmr_configuration();


  /* enable ack */
  i2c_ack_enable(I2C1, TRUE);
  i2c_interrupt_enable(I2C1, I2C_EVT_INT | I2C_DATA_INT | I2C_ERR_INT, TRUE);
//  i2c_slave_receive_int(&hi2cx, rx_buf, 2, I2C_TIMEOUT);
  while(1)
  {
	/* the Number of Pwm Output */
	PWM_DataLength = sizeof(src_buffer)/sizeof(src_buffer[0]);


	/* enable tmr3 overflow dma request */
	tmr_dma_request_enable(TMR3, TMR_OVERFLOW_DMA_REQUEST, TRUE);


 //   at32_led_off(LED3);
    at32_led_on(LED4);
	TMR3_DMA_Duty_Cycle();


    if(rx_buf[0] == 0x02){
    servo_val_set(rx_buf[1]);
	memcpy(src_buffer, servo_pos, BIT_NUMBER * sizeof(uint16_t));
    }
  }
}
/**
  * @}
  */

/**
  * @}
  */
