/**
  **************************************************************************
  * @file     main.c
  * @version  v2.0.0
  * @date     2020-11-02
  * @brief    main program
  **************************************************************************
  *                       Copyright notice & Disclaimer
  *
  * The software Board Support Package (BSP) that is made available to 
  * download from Artery official website is the copyrighted work of Artery. 
  * Artery authorizes customers to use, copy, and distribute the BSP 
  * software and its related documentation for the purpose of design and 
  * development in conjunction with Artery microcontrollers. Use of the 
  * software is governed by this copyright notice and the following disclaimer.
  *
  * THIS SOFTWARE IS PROVIDED ON "AS IS" BASIS WITHOUT WARRANTIES,
  * GUARANTEES OR REPRESENTATIONS OF ANY KIND. ARTERY EXPRESSLY DISCLAIMS,
  * TO THE FULLEST EXTENT PERMITTED BY LAW, ALL EXPRESS, IMPLIED OR
  * STATUTORY OR OTHER WARRANTIES, GUARANTEES OR REPRESENTATIONS,
  * INCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
  *
  **************************************************************************
  */

#include "at32f403a_407_board.h"
#include "at32f403a_407_clock.h"
#include "i2c_application.h"
#include <string.h>
#include "mg90s.h"

/** @addtogroup AT32F403A_periph_examples
  * @{
  */
  
/** @addtogroup 403A_I2C_communication_int I2C_communication_int
  * @{
  */

#define TMRx_PR 1000
#define BIT_NUMBER 8

#define I2C_TIMEOUT                      0xffffffFF
                                         
#define I2Cx_SPEED                       100000
#define I2Cx_ADDRESS                     0x15<<1

#define I2Cx_PORT                        I2C1
#define I2Cx_CLK                         CRM_I2C1_PERIPH_CLOCK

#define I2Cx_SCL_PIN                     GPIO_PINS_6             
#define I2Cx_SCL_GPIO_PORT               GPIOB       
#define I2Cx_SCL_GPIO_CLK                CRM_GPIOB_PERIPH_CLOCK

#define I2Cx_SDA_PIN                     GPIO_PINS_7             
#define I2Cx_SDA_GPIO_PORT               GPIOB                   
#define I2Cx_SDA_GPIO_CLK                CRM_GPIOB_PERIPH_CLOCK

#define I2Cx_EVT_IRQn                    I2C1_EVT_IRQn
#define I2Cx_ERR_IRQn                    I2C1_ERR_IRQn

#define BUF_SIZE                         2
//#define MASTER_BOARD

uint8_t tx_buf[BUF_SIZE] = {0x01, 0x02};//, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
uint8_t rx_buf[BUF_SIZE] = {2, 100};

i2c_handle_type hi2cx;

void error_handler(uint32_t error_code);
void i2c_lowlevel_init(i2c_handle_type* hi2c);



uint16_t PWM_DataLength=0;
tmr_output_config_type tmr_output_struct;

uint16_t src_buffer[BIT_NUMBER] = {};
/**
  * @brief  error handler program
  * @param  i2c_status
  * @retval none
  */
void error_handler(uint32_t error_code)
{
  while(1)
  {
    at32_led_toggle(LED2);
    delay_ms(500);
  }
}

/**
  * @brief  compare whether the valus of buffer 1 and buffer 2 are equal.
  * @param  buffer1: buffer 1 address.
            buffer2: buffer 2 address.
  * @retval 0: equal.
  *         1: unequal.
  */

/**
  * @brief  initializes peripherals used by the i2c.
  * @param  none
  * @retval none
  */
void i2c_lowlevel_init(i2c_handle_type* hi2c)
{
  gpio_init_type gpio_initstructure;
  
  if(hi2c->i2cx == I2Cx_PORT)
  {  
    /* i2c periph clock enable */
    crm_periph_clock_enable(I2Cx_CLK, TRUE);    
    crm_periph_clock_enable(I2Cx_SCL_GPIO_CLK, TRUE);
    crm_periph_clock_enable(I2Cx_SDA_GPIO_CLK, TRUE);
    
    /* gpio configuration */  
    gpio_initstructure.gpio_out_type       = GPIO_OUTPUT_OPEN_DRAIN;  
    gpio_initstructure.gpio_pull           = GPIO_PULL_UP;  
    gpio_initstructure.gpio_mode           = GPIO_MODE_MUX;  
    gpio_initstructure.gpio_drive_strength = GPIO_DRIVE_STRENGTH_MODERATE;
  
    /* configure i2c pins: scl */    
    gpio_initstructure.gpio_pins = I2Cx_SCL_PIN;
    gpio_init(I2Cx_SCL_GPIO_PORT, &gpio_initstructure);

    /* configure i2c pins: sda */     
    gpio_initstructure.gpio_pins = I2Cx_SDA_PIN;
    gpio_init(I2Cx_SDA_GPIO_PORT, &gpio_initstructure);
    
    /* configure and enable i2c interrupt */     
    nvic_irq_enable(I2Cx_EVT_IRQn, 0, 0);
    nvic_irq_enable(I2Cx_ERR_IRQn, 0, 0);    
    
    i2c_init(hi2c->i2cx, I2C_FSMODE_DUTY_2_1, I2Cx_SPEED);
    
    i2c_own_address1_set(hi2c->i2cx, I2C_ADDRESS_MODE_7BIT, I2Cx_ADDRESS);


  }
}


/**
  * @brief  configures the different system clocks.
  * @param  none
  * @retval none
  */
void crm_configuration(void)
{
  /* tmr clock enable */
  crm_periph_clock_enable(CRM_TMR3_PERIPH_CLOCK, TRUE);

  /* gpio clock enable */
  crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);

	/* dma clock enable */
  crm_periph_clock_enable(CRM_DMA1_PERIPH_CLOCK, TRUE);
}

/**
  * @brief  configures the PWM dma duty cycle parameters.
  * @param  none
  * @retval none
  */
void TMR3_DMA_Duty_Cycle(void)
{
	//for (int i = 0; i < 1000000; i++);

	/* set tmr channel CC value */
	tmr_channel_value_set(TMR3, TMR_SELECT_CHANNEL_4, 0);

  /* config set the number of data to be transferred by dma */
  dma_channel_enable(DMA1_CHANNEL3, FALSE);
  dma_data_number_set(DMA1_CHANNEL3, PWM_DataLength);
  dma_channel_enable(DMA1_CHANNEL3, TRUE);

	/* TMR enable counter */
	tmr_counter_enable(TMR3, TRUE);

	/* wait for the end of dma transfer */
	while (!dma_flag_get(DMA1_FDT3_FLAG));
	/* Clear dma flag */
	dma_flag_clear(DMA1_FDT3_FLAG);

	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET!=tmr_flag_get(TMR3, TMR_OVF_FLAG));
	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET != tmr_flag_get(TMR3, TMR_OVF_FLAG));

	/* TMR disable counter */
	tmr_counter_enable(TMR3, FALSE);

}


void gpio_configuration(void)
{
  gpio_init_type gpio_init_struct;

  gpio_default_para_init(&gpio_init_struct);

	/* configure PB1 tmr3_ch4 as output*/
  gpio_init_struct.gpio_pins = GPIO_PINS_1;
  gpio_init_struct.gpio_mode = GPIO_MODE_MUX;
  gpio_init(GPIOB, &gpio_init_struct);
}


void dma_configuration(void)
{
	dma_init_type dma_init_struct = {0};
	uint16_t index = 0;

	while(index < PWM_DataLength)
	{
		src_buffer[index] = (uint16_t) (((uint32_t) (src_buffer[index]) * (TMRx_PR)) / (1000));
		index++;
	}

  /* dma1 channel7 configuration */
  dma_default_para_init(&dma_init_struct);

  dma_init_struct.buffer_size = PWM_DataLength;
  dma_init_struct.direction = DMA_DIR_MEMORY_TO_PERIPHERAL;
  dma_init_struct.memory_base_addr = (uint32_t)src_buffer;
  dma_init_struct.memory_data_width = DMA_MEMORY_DATA_WIDTH_HALFWORD;
  dma_init_struct.memory_inc_enable = TRUE;
  dma_init_struct.peripheral_base_addr = (uint32_t)&TMR3->c4dt;
  dma_init_struct.peripheral_data_width= DMA_PERIPHERAL_DATA_WIDTH_HALFWORD;
  dma_init_struct.peripheral_inc_enable  = FALSE;
  dma_init_struct.priority = DMA_PRIORITY_HIGH;
  dma_init_struct.loop_mode_enable = FALSE;
  dma_init(DMA1_CHANNEL3, &dma_init_struct);
}


/**
  * @brief  configure the tmr parameters.
  * @param  none
  * @retval none
  */
void tmr_configuration(void)
{
  /* Init TMR3 */
	//2603879
  tmr_base_init(TMR3, TMRx_PR-1, 11);
  tmr_cnt_dir_set(TMR3, TMR_COUNT_UP);

	/* TMR configuration as output mode */
  tmr_output_default_para_init(&tmr_output_struct);
  tmr_output_struct.oc_mode = TMR_OUTPUT_CONTROL_PWM_MODE_A;
  tmr_output_struct.oc_output_state = TRUE;
  tmr_output_struct.oc_polarity = TMR_OUTPUT_ACTIVE_LOW;

	/* TMR3 channel 4 configuration */
  tmr_output_channel_config(TMR3, TMR_SELECT_CHANNEL_4, &tmr_output_struct);

	/* enable tmr output channel buffer */
  tmr_output_channel_buffer_enable(TMR3, TMR_SELECT_CHANNEL_4, TRUE);
}

/**
  * @brief  main function.
  * @param  none
  * @retval none
  */
int main(void)
{
    i2c_status_type i2c_status;

    /* config nvic priority group */
    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);

    system_clock_config();
  
    at32_board_init();

    hi2cx.i2cx = I2Cx_PORT;
    i2c_config(&hi2cx);
//  i2c_interrupt_enable(I2C1, I2C_EVT_INT | I2C_DATA_INT | I2C_ERR_INT, TRUE);
    /* enable tmr/gpio clock */

    crm_configuration();

    /* tmr gpio configuration */
    gpio_configuration();

    /* dma configuration */
    dma_configuration();

    /* tmr configuration */
    tmr_configuration();

    hi2cx.mode   = I2C_INT_SLA_RX;
	hi2cx.status = 1;
	hi2cx.pbuff  = rx_buf;
	hi2cx.pcount = 2;
	hi2cx.timeout = 0xffffffff;

  /* enable ack */
  i2c_ack_enable(I2C1, TRUE);
  i2c_interrupt_enable(I2C1, I2C_EVT_INT | I2C_DATA_INT | I2C_ERR_INT, TRUE);
//  i2c_slave_receive_int(&hi2cx, rx_buf, 2, I2C_TIMEOUT);
  while(1)
  {
    
#if defined (MASTER_BOARD)     
  
    /* wait for key USER_BUTTON press before starting the communication */
    while(at32_button_press() != USER_BUTTON)
    {
    }
    
    /* start the request reception process */  
    if((i2c_status = i2c_master_transmit_int(&hi2cx, I2Cx_ADDRESS, tx_buf, BUF_SIZE, I2C_TIMEOUT)) != I2C_OK)
    { 
      error_handler(i2c_status);
    }
    
    /* wait for the communication to end */  
    if(i2c_wait_end(&hi2cx, I2C_TIMEOUT) != I2C_OK)
    {
      error_handler(i2c_status);
    }       
    
#else
	/* the Number of Pwm Output */
	PWM_DataLength = sizeof(src_buffer)/sizeof(src_buffer[0]);


	/* enable tmr3 overflow dma request */
	tmr_dma_request_enable(TMR3, TMR_OVERFLOW_DMA_REQUEST, TRUE);


 //   at32_led_off(LED3);
    at32_led_on(LED4);
    /* start the transmission process */
//    if((i2c_status = i2c_slave_receive_int(&hi2cx, rx_buf, 3, I2C_TIMEOUT)) != I2C_OK)
//    {
//      error_handler(i2c_status);
//    }

//    at32_led_off(LED4);
//    at32_led_on(LED3);

//    /* wait for the communication to end */
//    if(i2c_wait_end(&hi2cx, I2C_TIMEOUT) != I2C_OK)
//    {
//      error_handler(i2c_status);
//    }

//if(buffer_compare(tx_buf, rx_buf, BUF_SIZE) == 0)
//{
//  at32_led_on(LED3);
//}
//else
//{
//  error_handler(i2c_status);
//}


    if(rx_buf[0] == 0x02){
    servo_val_set(rx_buf[1]);
	memcpy(src_buffer, servo_pos, BIT_NUMBER * sizeof(uint16_t));
    }


	TMR3_DMA_Duty_Cycle();
	//delay_us(100000);
    //at32_led_off(LED4);
#endif
  
  }   
}

/**
  * @}
  */ 

/**
  * @}
  */
