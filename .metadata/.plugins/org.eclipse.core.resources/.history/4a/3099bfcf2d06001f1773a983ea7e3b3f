
#include "at32f403a_407_board.h"
#include "at32f403a_407_clock.h"



#define TMRx_PR 1000
#define BIT_NUMBER 8
#define BUF_SIZE                         2

uint8_t rx_buf[BUF_SIZE] = {2, 200};

uint16_t PWM_DataLength=0;
tmr_output_config_type tmr_output_struct;

uint16_t src_buffer[BIT_NUMBER] = {};
/**
  * @brief  error handler program
  * @param  i2c_status
  * @retval none
  */
void error_handler(uint32_t error_code)
{
  while(1)
  {
    at32_led_toggle(LED2);
    delay_ms(500);
  }
}



/**
  * @brief  configures the different system clocks.
  * @param  none
  * @retval none
  */
void crm_configuration(void)
{
  /* tmr clock enable */
  crm_periph_clock_enable(CRM_TMR3_PERIPH_CLOCK, TRUE);

  /* gpio clock enable */
  crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);

	/* dma clock enable */
  crm_periph_clock_enable(CRM_DMA1_PERIPH_CLOCK, TRUE);
}

/**
  * @brief  configures the PWM dma duty cycle parameters.
  * @param  none
  * @retval none
  */
void TMR3_DMA_Duty_Cycle(void)
{
	//for (int i = 0; i < 1000000; i++);

	/* set tmr channel CC value */
	tmr_channel_value_set(TMR3, TMR_SELECT_CHANNEL_4, 0);

  /* config set the number of data to be transferred by dma */
  dma_channel_enable(DMA1_CHANNEL3, FALSE);
  dma_data_number_set(DMA1_CHANNEL3, PWM_DataLength);
  dma_channel_enable(DMA1_CHANNEL3, TRUE);

	/* TMR enable counter */
	tmr_counter_enable(TMR3, TRUE);

	/* wait for the end of dma transfer */
	while (!dma_flag_get(DMA1_FDT3_FLAG));
	/* Clear dma flag */
	dma_flag_clear(DMA1_FDT3_FLAG);

	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET!=tmr_flag_get(TMR3, TMR_OVF_FLAG));
	/* Clear TMR3 update Interrupt  pending bit */
	tmr_flag_clear(TMR3, TMR_OVF_FLAG);
  while(SET != tmr_flag_get(TMR3, TMR_OVF_FLAG));

	/* TMR disable counter */
	tmr_counter_enable(TMR3, FALSE);

}


void gpio_configuration(void)
{
  gpio_init_type gpio_init_struct;

  gpio_default_para_init(&gpio_init_struct);

	/* configure PB1 tmr3_ch4 as output*/
  gpio_init_struct.gpio_pins = GPIO_PINS_1;
  gpio_init_struct.gpio_mode = GPIO_MODE_MUX;
  gpio_init(GPIOB, &gpio_init_struct);
}


void dma_configuration(void)
{
	dma_init_type dma_init_struct = {0};
	uint16_t index = 0;

	while(index < PWM_DataLength)
	{
		src_buffer[index] = (uint16_t) (((uint32_t) (src_buffer[index]) * (TMRx_PR)) / (1000));
		index++;
	}

  /* dma1 channel7 configuration */
  dma_default_para_init(&dma_init_struct);

  dma_init_struct.buffer_size = PWM_DataLength;
  dma_init_struct.direction = DMA_DIR_MEMORY_TO_PERIPHERAL;
  dma_init_struct.memory_base_addr = (uint32_t)src_buffer;
  dma_init_struct.memory_data_width = DMA_MEMORY_DATA_WIDTH_HALFWORD;
  dma_init_struct.memory_inc_enable = TRUE;
  dma_init_struct.peripheral_base_addr = (uint32_t)&TMR3->c4dt;
  dma_init_struct.peripheral_data_width= DMA_PERIPHERAL_DATA_WIDTH_HALFWORD;
  dma_init_struct.peripheral_inc_enable  = FALSE;
  dma_init_struct.priority = DMA_PRIORITY_HIGH;
  dma_init_struct.loop_mode_enable = FALSE;
  dma_init(DMA1_CHANNEL3, &dma_init_struct);
}


/**
  * @brief  configure the tmr parameters.
  * @param  none
  * @retval none
  */
void tmr_configuration(void)
{
  /* Init TMR3 */
	//2603879
  tmr_base_init(TMR3, TMRx_PR-1, 2);
  tmr_cnt_dir_set(TMR3, TMR_COUNT_UP);

	/* TMR configuration as output mode */
  tmr_output_default_para_init(&tmr_output_struct);
  tmr_output_struct.oc_mode = TMR_OUTPUT_CONTROL_PWM_MODE_A;
  tmr_output_struct.oc_output_state = TRUE;
  tmr_output_struct.oc_polarity = TMR_OUTPUT_ACTIVE_LOW;

	/* TMR3 channel 4 configuration */
  tmr_output_channel_config(TMR3, TMR_SELECT_CHANNEL_4, &tmr_output_struct);

	/* enable tmr output channel buffer */
  tmr_output_channel_buffer_enable(TMR3, TMR_SELECT_CHANNEL_4, TRUE);
}

/**
  * @brief  main function.
  * @param  none
  * @retval none
  */
int main(void)
{
    i2c_status_type i2c_status;

    /* config nvic priority group */
    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);

    system_clock_config();
  
    at32_board_init();
    crm_configuration();

    /* tmr gpio configuration */
    gpio_configuration();

    /* dma configuration */
    dma_configuration();

    /* tmr configuration */
    tmr_configuration();

  /* enable ack */
  i2c_ack_enable(I2C1, TRUE);
  i2c_interrupt_enable(I2C1, I2C_EVT_INT | I2C_DATA_INT | I2C_ERR_INT, TRUE);
//  i2c_slave_receive_int(&hi2cx, rx_buf, 2, I2C_TIMEOUT);
  while(1)
  {
    

	/* the Number of Pwm Output */
	PWM_DataLength = sizeof(src_buffer)/sizeof(src_buffer[0]);


	/* enable tmr3 overflow dma request */
	tmr_dma_request_enable(TMR3, TMR_OVERFLOW_DMA_REQUEST, TRUE);
    at32_led_on(LED4);
    if(rx_buf[0] == 0x02){
    servo_val_set(rx_buf[1]);
	memcpy(src_buffer, servo_pos, BIT_NUMBER * sizeof(uint16_t));
    }

	TMR3_DMA_Duty_Cycle();


  
  }   
}

